# 11. Architecture de Services Domain-Driven Design

Date: 2025-09-04

## Statut

Propos√©

## Le Probl√®me : Un Service R√©el de Notre Codebase

Regardons un service typique de notre application - celui qui g√®re la cr√©ation des plans d'action. Ce code illustre parfaitement les probl√®mes que nous rencontrons quotidiennement :

```typescript
@Injectable()
export class PlanService {
  constructor(
    private readonly databaseService: DatabaseService,
    private readonly permissionService: PermissionService,
    private readonly cacheService: CacheService,
    private readonly eventBus: EventBus,
    private readonly ficheService: FicheService,
    private readonly auditService: AuditService
  ) {}

  async createPlan(request: CreatePlanRequest, user: AuthenticatedUser): Promise<PlanResponse> {
    // üî• AUTORISATION m√©lang√©e avec logique m√©tier
    if (!await this.permissionService.isAllowed(user, 'PLANS.CREATE', request.collectiviteId)) {
      throw new Error('Forbidden');
    }

    // üî• VALIDATION m√©tier √©parpill√©e 
    if (!request.nom || request.nom.trim().length === 0) {
      throw new Error('Le nom du plan est obligatoire');
    }
    
    if (request.nom.length > 255) {
      throw new Error('Le nom du plan ne peut pas d√©passer 255 caract√®res');
    }

    // üî• R√àGLES M√âTIER enfouies dans le service
    if (request.type === 'PCAET') {
      if (!request.referents || request.referents.length === 0) {
        throw new Error('Un plan PCAET doit avoir au moins un r√©f√©rent');
      }
      
      // Validation sp√©cifique PCAET cach√©e ici
      const hasEnergiePilote = request.referents.some(r => r.competence === 'ENERGIE');
      if (!hasEnergiePilote) {
        throw new Error('Un plan PCAET doit avoir un r√©f√©rent √©nergie');
      }
    }

    // üî• GESTION D'ERREURS incoh√©rente (throw Error vs custom errors)
    let savedPlan;
    try {
      // üî• TRANSACTION et PERSISTENCE m√©lang√©es
      savedPlan = await this.databaseService.db.transaction(async (tx) => {
        const planData = {
          nom: request.nom.trim(),
          type: request.type,
          collectiviteId: request.collectiviteId,
          statut: 'brouillon',
          createdBy: user.id,
          createdAt: new Date()
        };

        const plan = await tx.insert(plans).values(planData).returning();
        
        // üî• LOGIQUE M√âTIER cach√©e dans la persistance
        if (request.createDefaultStructure) {
          const defaultAxes = await this.getDefaultAxesForType(request.type, tx);
          for (const axe of defaultAxes) {
            await tx.insert(axes).values({
              planId: plan[0].id,
              nom: axe.nom,
              ordre: axe.ordre
            });
          }
        }

        // üî• EFFETS DE BORD m√©lang√©s avec la logique principale
        await this.auditService.logPlanCreation(plan[0].id, user.id, tx);
        
        return plan[0];
      });
    } catch (error) {
      // üî• GESTION D'ERREURS g√©n√©rique et peu informative
      console.error('Erreur cr√©ation plan:', error);
      throw new Error('Impossible de cr√©er le plan');
    }

    // üî• CACHE et √âV√âNEMENTS m√©lang√©s avec la logique principale
    try {
      await Promise.all([
        this.cacheService.invalidate(`plans:${request.collectiviteId}`),
        this.eventBus.publish(new PlanCreatedEvent(savedPlan.id, user.id))
      ]);
    } catch (error) {
      // Les erreurs de cache/√©v√©nements sont silencieuses mais le plan est cr√©√©
      console.warn('Erreur effets de bord:', error);
    }

    // üî• TRANSFORMATION de donn√©es dans le service
    return {
      id: savedPlan.id,
      nom: savedPlan.nom,
      type: savedPlan.type,
      statut: savedPlan.statut,
      collectiviteId: savedPlan.collectiviteId,
      createdAt: savedPlan.createdAt.toISOString(),
      canEdit: await this.permissionService.isAllowed(user, 'PLANS.EDIT', savedPlan.id)
    };
  }

  // üî• M√™me service, autre m√©thode avec DUPLICATION de logique
  async updatePlan(planId: number, updates: UpdatePlanRequest, user: AuthenticatedUser): Promise<PlanResponse> {
    // Autorisation dupliqu√©e...
    if (!await this.permissionService.isAllowed(user, 'PLANS.EDIT', planId)) {
      throw new Error('Forbidden');
    }

    // Validation dupliqu√©e...
    if (updates.nom && updates.nom.trim().length === 0) {
      throw new Error('Le nom du plan est obligatoire');
    }

    // R√®gles m√©tier dupliqu√©es et √©parpill√©es...
    if (updates.type === 'PCAET') {
      // ... m√™me logique qu'au-dessus mais l√©g√®rement diff√©rente
    }

    // ... 50 autres lignes de code similaire
  }
}
```

### üîç Constats sur Ce Code

**1. Impossible √† tester unitairement**
- Pour tester une r√®gle m√©tier simple ("un PCAET doit avoir un r√©f√©rent √©nergie"), il faut mocker 6 d√©pendances
- Les tests sont lents et fragiles

**2. R√®gles m√©tier √©parpill√©es et dupliqu√©es**
- La logique "qu'est-ce qui fait un plan valide" est r√©partie dans 3 m√©thodes diff√©rentes
- Impossible de comprendre les r√®gles m√©tier sans lire tout le service

**3. Gestion d'erreurs incoh√©rente**
- `throw new Error()` g√©n√©rique partout
- Impossible de distinguer les erreurs m√©tier des erreurs techniques
- Debugging complexe

**4. Responsabilit√©s multiples dans une m√™me classe**
- Autorisation + validation + r√®gles m√©tier + persistance + cache + √©v√©nements
- Changer une r√®gle m√©tier peut impacter l'autorisation ou le cache

**5. √âvolutivit√© limit√©e**
- Ajouter un nouveau type de plan n√©cessite de modifier plusieurs endroits
- La logique m√©tier n'est pas r√©utilisable dans d'autres contextes

## La Solution : Refactoring Progressif Vers DDD

Au lieu de r√©√©crire tout d'un coup, nous allons progressivement extraire les responsabilit√©s pour faire √©merger une architecture claire. Suivez cette transformation √©tape par √©tape :

## √âtape 1 : Extraire la Logique M√©tier Pure

**üí° TAKE #1** : Les r√®gles m√©tier ne devraient d√©pendre de rien d'autre que du domaine lui-m√™me.

Commen√ßons par extraire toute la logique de validation et les r√®gles m√©tier dans un objet d√©di√© :

```typescript
// AVANT : Logique √©parpill√©e dans le service
// APR√àS : Logique centralis√©e et testable

import { z } from 'zod';

// Result type pour propagation d'erreurs
type Result<T, E> = { success: true; value: T } | { success: false; error: E };

// Helper functions pour construire les Results
const success = <T>(value: T): { success: true; value: T } => ({ success: true, value });
const failure = <E>(error: E): { success: false; error: E } => ({ success: false, error });

// Combine multiple Results into a single Result with an array of values
const combineResults = <T, E>(results: Result<T, E>[]): Result<T[], E> => {
  const values: T[] = [];
  for (const result of results) {
    if (!result.success) {
      return result;
    }
    values.push(result.value);
  }
  return success(values);
};

// Types d'erreurs m√©tier explicites
class InvalidPlanName extends Error {
  readonly _tag = 'InvalidPlanName';
  constructor(public readonly name: string) {
    super(`Invalid plan name: "${name}"`);
    this.name = 'InvalidPlanName';
  }
}
class MissingPcaetReferent extends Error {
  readonly _tag = 'MissingPcaetReferent';
  constructor() {
    super('Un plan PCAET doit avoir au moins un r√©f√©rent');
    this.name = 'MissingPcaetReferent';
  }
}
class MissingEnergyExpertise extends Error {
  readonly _tag = 'MissingEnergyExpertise';
  constructor() {
    super('Un plan PCAET doit avoir un r√©f√©rent √©nergie');
    this.name = 'MissingEnergyExpertise';
  }
}

type PlanDomainError = InvalidPlanName | MissingPcaetReferent | MissingEnergyExpertise;

// Sch√©ma de validation avec transformation
const planSchema = z.object({
  nom: z.string().min(1).max(255).transform(s => s.trim()),
  type: z.enum(['PAT', 'PCAET', 'AUTRE']).nullable(),
  collectiviteId: z.number().positive(),
  referents: z.array(z.object({
    userId: z.string().uuid(),
    nom: z.string().min(1),
    competence: z.enum(['ENERGIE', 'TRANSPORT', 'DECHETS', 'AUTRE'])
  })).default([])
});

export type Plan = z.infer<typeof planSchema>;
export type CreatePlanData = z.input<typeof planSchema>;

// üéØ LOGIQUE M√âTIER PURE - Aucune d√©pendance externe
export const PlanOperations = {
  // Factory avec toutes les r√®gles m√©tier centralis√©es
  create: (input: CreatePlanData): Result<Plan, PlanDomainError> => {
    // Validation structurelle
    const validation = planSchema.safeParse(input);
    if (!validation.success) {
      return failure(new InvalidPlanName(input.nom || ''));
    }

    const plan = validation.data;

    // R√®gles m√©tier sp√©cifiques PCAET
    if (plan.type === 'PCAET') {
      if (plan.referents.length === 0) {
        return failure(new MissingPcaetReferent());
      }
      
      const hasEnergyExpert = plan.referents.some(r => r.competence === 'ENERGIE');
      if (!hasEnergyExpert) {
        return failure(new MissingEnergyExpertise());
      }
    }

    return success(plan);
  },

  // Autres r√®gles m√©tier centralis√©es
  canTransitionTo: (plan: Plan, newStatus: PlanStatus): boolean => {
    // Toute la logique de transition d'√©tat ici
    return true; // Simplified
  },

  getDefaultAxesForType: (type: Plan['type']): Array<{nom: string, ordre: number}> => {
    // Logique de structure par d√©faut
    if (type === 'PCAET') {
      return [
        { nom: 'R√©duction des √©missions', ordre: 1 },
        { nom: 'Adaptation au changement climatique', ordre: 2 },
        { nom: 'Production d\'√©nergie renouvelable', ordre: 3 }
      ];
    }
    return [
      { nom: 'Axe principal', ordre: 1 }
    ];
  }
};
```

**R√©sultat de l'√âtape 1 :**
- Toutes les r√®gles m√©tier sont dans un seul endroit
- Testable unitairement sans aucune d√©pendance
- Gestion d'erreurs explicite et typ√©e
- R√©utilisable dans d'autres contextes

```typescript
// Test unitaire simplifi√©
describe('PlanOperations.create', () => {
  it('refuse un plan PCAET sans r√©f√©rent √©nergie', () => {
    const input = {
      nom: 'Mon PCAET',
      type: 'PCAET' as const,
      collectiviteId: 1,
      referents: [{ userId: 'uuid', nom: 'Jean', competence: 'TRANSPORT' as const }]
    };
    
    const result = PlanOperations.create(input);
    
    expect(result.success).toBe(false);
    if (!result.success) {
      expect(result.error._tag).toBe('MissingEnergyExpertise');
    }
  });
});
```

## √âtape 2 : Cr√©er un Service M√©tier (Domain Service)

**üí° TAKE #2** : Certaines op√©rations m√©tier ne peuvent pas √™tre exprim√©es purement et n√©cessitent des d√©pendances (comme les repositories), mais elles restent dans le domaine.

Cr√©ons un service m√©tier qui orchestre les objets du domaine et g√®re la persistance :

```typescript
// Erreurs li√©es √† la persistance du domaine
class PlanNotFound extends Error {
  readonly _tag = 'PlanNotFound';
  constructor(public readonly planId: number) {
    super(`Plan not found: ${planId}`);
    this.name = 'PlanNotFound';
  }
}
class PersistenceError extends Error {
  readonly _tag = 'PersistenceError';
  constructor(public readonly cause: unknown) {
    super(`Persistence error: ${cause instanceof Error ? cause.message : String(cause)}`);
    this.name = 'PersistenceError';
  }
}

type PlanDomainServiceError = PlanDomainError | PlanNotFound | PersistenceError;

// Interface du repository (contrat du domaine)
interface PlanRepository {
  save: (plan: Plan, tx?: Transaction) => Promise<Result<Plan, PersistenceError>>;
  findById: (id: number, tx?: Transaction) => Promise<Result<Plan | null, PersistenceError>>;
}

// üéØ SERVICE M√âTIER - Orchestre les objets du domaine + persistance
@Injectable()
export class PlanDomainService {
  constructor(
    @Inject('PlanRepository')
    private readonly planRepository: PlanRepository
  ) {}

  // Cr√©ation avec logique m√©tier + persistance
  async createPlan(
    input: CreatePlanData,
    tx?: Transaction
  ): Promise<Result<Plan, PlanDomainServiceError>> {
    // 1. Appliquer les r√®gles m√©tier (pure)
    const planResult = PlanOperations.create(input);
    if (!planResult.success) {
      return planResult;
    }

    // 2. Persister (avec gestion d'erreurs explicite)
    const savedPlanResult = await this.planRepository.save(planResult.value, tx);
    if (!savedPlanResult.success) {
      return savedPlanResult;
    }

    return savedPlanResult;
  }

  // Cr√©ation avec structure par d√©faut (logique m√©tier complexe)
  async createPlanWithDefaultStructure(
    input: CreatePlanData,
    tx?: Transaction
  ): Promise<Result<{ plan: Plan; axes: Axe[] }, PlanDomainServiceError>> {
    // 1. Cr√©er le plan avec validation m√©tier
    const planResult = await this.createPlan(input, tx);
    if (!planResult.success) {
      return planResult;
    }
    const plan = planResult.value;

    // 2. G√©n√©rer la structure par d√©faut (logique m√©tier)
    const defaultAxesData = PlanOperations.getDefaultAxesForType(plan.type);
    
    // 3. Cr√©er les axes avec leurs propres r√®gles m√©tier (en parall√®le)
    const axeCreationResults = defaultAxesData.map(axeData =>
      AxeOperations.create({
        ...axeData,
        planId: plan.id
      })
    );
    
    const validatedAxesResult = combineResults(axeCreationResults);
    if (!validatedAxesResult.success) {
      return validatedAxesResult;
    }
    
    // Sauvegarder tous les axes en parall√®le
    const saveResults = await Promise.all(
      validatedAxesResult.value.map(axe => this.axeRepository.save(axe, tx))
    );
    
    const axesResult = combineResults(saveResults);
    if (!axesResult.success) {
      return axesResult;
    }

    return success({ plan, axes: axesResult.value });
  }

  // Mise √† jour avec r√®gles m√©tier
  async updatePlan(
    planId: number,
    updates: Partial<CreatePlanData>,
    tx?: Transaction
  ): Promise<Result<Plan, PlanDomainServiceError>> {
    // 1. R√©cup√©rer le plan existant
    const existingPlanResult = await this.planRepository.findById(planId, tx);
    if (!existingPlanResult.success) {
      return existingPlanResult;
    }
    
    const existingPlan = existingPlanResult.value;
    if (!existingPlan) {
      return failure(new PlanNotFound(planId));
    }

    // 2. Appliquer les modifications avec validation m√©tier
    const updatedData = { ...existingPlan, ...updates };
    const validatedResult = PlanOperations.create(updatedData);
    if (!validatedResult.success) {
      return validatedResult;
    }

    // 3. Persister
    const savedPlanResult = await this.planRepository.save(validatedResult.value, tx);
    if (!savedPlanResult.success) {
      return savedPlanResult;
    }

    return savedPlanResult;
  }
}
```

**R√©sultat de l'√âtape 2 :**
- Logique m√©tier complexe centralis√©e (cr√©ation + structure par d√©faut)
- Gestion d'erreurs explicite avec le pattern Result
- Pas d'exceptions lanc√©es, erreurs propag√©es de mani√®re typ√©e
- Transactions g√©r√©es au bon niveau
- Testable avec des mocks simples du repository
- R√©utilisable par diff√©rents services d'application

## √âtape 3 : Cr√©er un Service d'Application (Coordination)

**üí° TAKE #3** : Le service d'application orchestre tout ce qui n'est PAS de la logique m√©tier : autorisations, cache, √©v√©nements, transformations de donn√©es.

```typescript
// Erreurs d'application (non-m√©tier)
class Forbidden extends Error {
  readonly _tag = 'Forbidden';
  constructor(public readonly reason: string) {
    super(`Forbidden: ${reason}`);
    this.name = 'Forbidden';
  }
}
class ApplicationError extends Error {
  readonly _tag = 'ApplicationError';
  constructor(public readonly code: string, message: string) {
    super(`${code}: ${message}`);
    this.name = 'ApplicationError';
  }
}

type PlanApplicationError = Forbidden | ApplicationError;

// üéØ SERVICE D'APPLICATION - Coordination et orchestration
@Injectable()
export class PlanApplicationService {
  constructor(
    private readonly planDomainService: PlanDomainService,
    private readonly permissionService: PermissionService,
    private readonly cacheService: CacheService,
    private readonly eventBus: EventBus,
    private readonly auditService: AuditService,
    private readonly databaseService: DatabaseService
  ) {}

  async createPlan(
    request: CreatePlanRequest,
    user: AuthenticatedUser
  ): Promise<Result<PlanResponse, PlanApplicationError>> {
    
    // 1. üîê AUTORISATION (responsabilit√© application)
    const hasPermission = await this.permissionService.isAllowed(
      user,
      'PLANS.CREATE',
      request.collectiviteId
    );
    if (!hasPermission) {
      return failure(new Forbidden('Cannot create plan for this collectivit√©'));
    }

    // 2. üèóÔ∏è COORDINATION M√âTIER avec transaction
    const domainResult = await this.databaseService.db.transaction(async (tx) => {
      // D√©l√©guer au service m√©tier
      const planResult = await this.planDomainService.createPlanWithDefaultStructure({
        ...request,
        createdBy: user.id,
        createdAt: new Date()
      }, tx);
      
      // Propager l'erreur si pr√©sente
      if (!planResult.success) {
        throw planResult.error; // Will rollback transaction
      }

      // Audit (effet de bord m√©tier mais g√©r√© par l'application)
      await this.auditService.logPlanCreation(planResult.value.plan.id, user.id, tx);

      return planResult.value;
    });

    // 3. üîÑ EFFETS DE BORD (responsabilit√© application)
    try {
      await Promise.all([
        this.cacheService.invalidate(`plans:${request.collectiviteId}`),
        this.eventBus.publish(new PlanCreatedEvent({
          planId: domainResult.plan.id,
          collectiviteId: domainResult.plan.collectiviteId,
          createdBy: user.id
        }))
      ]);
    } catch (error) {
      // Les erreurs de cache/√©v√©nements ne font pas √©chouer l'op√©ration
      console.warn('Side effects failed:', error);
    }

    // 4. üìã TRANSFORMATION DE DONN√âES (responsabilit√© application)
    const response = await this.toPlanResponse(domainResult.plan, user);
    
    return success(response);
  }

  // Transformation des donn√©es du domaine vers l'API
  private async toPlanResponse(plan: Plan, user: AuthenticatedUser): Promise<PlanResponse> {
    return {
      id: plan.id,
      nom: plan.nom,
      type: plan.type,
      statut: plan.statut,
      collectiviteId: plan.collectiviteId,
      createdAt: plan.createdAt.toISOString(),
      // Permissions calcul√©es au niveau application
      canEdit: await this.permissionService.isAllowed(user, 'PLANS.EDIT', plan.id),
      canDelete: await this.permissionService.isAllowed(user, 'PLANS.DELETE', plan.id)
    };
  }
}
```

**R√©sultat de l'√âtape 3 :**
- Service d'application focalis√© sur l'orchestration
- S√©paration claire : m√©tier vs coordination
- Gestion des effets de bord isol√©e
- Transformation de donn√©es centralis√©e
- Autorisations g√©r√©es au bon niveau

## √âtape 4 : √âliminer le Service Original

**üí° TAKE #4** : Le service original n'a plus de raison d'exister ! Le routeur peut directement appeler le service d'application.

```typescript
// Service interm√©diaire qui ne fait que d√©l√©guer
@Injectable()
export class PlanService {
  constructor(private readonly planApplicationService: PlanApplicationService) {}

  async createPlan(request: CreatePlanRequest, user: AuthenticatedUser): Promise<PlanResponse> {
    const result = await this.planApplicationService.createPlan(request, user);
    // Juste une conversion d'erreurs...
    if (!result.success) throw new BadRequestException(result.error);
    return result.value;
  }
}

// Alternative : Le routeur appelle directement le service d'application
@Injectable()
export class PlanRouter {
  constructor(
    private readonly trpc: TrpcService,
    private readonly planApplicationService: PlanApplicationService  // Direct !
  ) {}

  router = this.trpc.router({
    create: this.trpc.authedProcedure
      .input(createPlanRequestSchema)
      .mutation(async ({ input, ctx }) => {
        const result = await this.planApplicationService.createPlan(input, ctx.user);
        
        // Conversion d'erreurs directement dans le routeur - gestion gracieuse
        if (!result.success) {
          const error = result.error;
          if (error._tag === 'Forbidden') {
            throw new TRPCError({ code: 'FORBIDDEN', message: error.reason });
          }
          throw new TRPCError({ code: 'BAD_REQUEST', message: error.message });
        }
        
        return result.value;
      })
  });
}
```

**Consid√©rations sur le service interm√©diaire :**

1. **Absence de logique m√©tier** : Il ne fait que d√©l√©guer
2. **Absence de coordination** : Aucune orchestration
3. **Mapping d'erreurs uniquement** : Le routeur peut assumer cette responsabilit√©
4. **Couche suppl√©mentaire** : Ajoute de la complexit√©
5. **Simplification des tests** : Un composant en moins √† tester

## üéØ Comparaison Avant/Apr√®s

### AVANT (Monolithe de 150+ lignes)
```typescript
// Tout m√©lang√© dans une seule classe
class PlanService {
  // 6 d√©pendances inject√©es
  // Autorisation + validation + r√®gles m√©tier + persistance + cache + √©v√©nements
  // 150+ lignes par m√©thode
  // Tests unitaires complexes
  // Logique dupliqu√©e entre create/update
}
```

### APR√àS (Responsabilit√©s s√©par√©es)
```typescript
// Logique m√©tier pure et testable
const PlanOperations = {
  create: (input) => Result<Plan, DomainError>  // 20 lignes, 0 d√©pendance
}

// Transformations de donn√©es isol√©es
const PlanAdapter = {
  toDomain: (dbRow) => Result<Plan, AdapterError>  // 15 lignes, 0 d√©pendance
  toDb: (plan) => Result<DbRow, AdapterError>      // 15 lignes, 0 d√©pendance
}

// Service m√©tier avec persistance
class PlanDomainService {
  createPlan: (input, tx?) => Promise<Result<Plan, DomainError>>  // 30 lignes, 1 d√©pendance
}

// Service d'application pour coordination
class PlanApplicationService {
  createPlan: (request, user) => Promise<Result<Response, AppError>>  // 40 lignes, 5 d√©pendances
}

// Routeur appelle directement le service d'application
class PlanRouter {
  // Gestion gracieuse des erreurs + d√©l√©gation  // 15 lignes, 1 d√©pendance
}
```

## üí° Les Concepts DDD √âmergent Naturellement

En refactorisant notre service, nous avons naturellement d√©couvert les concepts DDD sans les imposer :

**üéØ Entit√© (Entity)** : `Plan` - Objet avec identit√© unique qui √©volve dans le temps
**üéØ Objet Valeur (Value Object)** : `PlanType`, `PlanStatus` - Valeurs immuables d√©finies par leurs attributs  
**üéØ Agr√©gat (Aggregate)** : `Plan + Axes` - Groupe d'objets avec invariants partag√©s
**üéØ Service M√©tier (Domain Service)** : `PlanDomainService` - Logique m√©tier qui ne peut pas √™tre dans une entit√© (=> du code est n√©cessaire pour exprimer cette logique)
**üéØ Service d'Application** : `PlanApplicationService` - Orchestration et coordination
**üéØ Repository** : Interface d'acc√®s aux donn√©es orient√©e domaine
**üéØ Adapter** : `PlanAdapter` - Transformations entre formats DB et Domain

## Architecture R√©sultante

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    SERVICE D'APPLICATION                   ‚îÇ
‚îÇ  ‚Ä¢ Autorisation et Permissions                            ‚îÇ
‚îÇ  ‚Ä¢ Cache et Optimisation                                  ‚îÇ
‚îÇ  ‚Ä¢ Publication d'√âv√©nements                               ‚îÇ
‚îÇ  ‚Ä¢ Coordination des Transactions                          ‚îÇ
‚îÇ  ‚Ä¢ Transformation des Donn√©es (API ‚Üî Domaine)            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                      ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                   SERVICE M√âTIER                          ‚îÇ
‚îÇ  ‚Ä¢ Logique M√©tier et R√®gles du Domaine                   ‚îÇ
‚îÇ  ‚Ä¢ Orchestration des Objets M√©tier                       ‚îÇ
‚îÇ  ‚Ä¢ Workflows M√©tier avec Persistance                     ‚îÇ
‚îÇ  ‚Ä¢ Invariants et Contraintes                             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                      ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              OBJETS M√âTIER + REPOSITORIES                 ‚îÇ
‚îÇ  ‚Ä¢ Entit√©s avec Comportement M√©tier                      ‚îÇ
‚îÇ  ‚Ä¢ Objets de Valeur Immuables                            ‚îÇ
‚îÇ  ‚Ä¢ Repository Interfaces                                  ‚îÇ
‚îÇ  ‚Ä¢ Logique M√©tier Pure (Operations)                      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                      ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                     ADAPTERS                              ‚îÇ
‚îÇ  ‚Ä¢ Transformations DB ‚Üî Domain                           ‚îÇ
‚îÇ  ‚Ä¢ Mapping des Types et Formats                          ‚îÇ
‚îÇ  ‚Ä¢ Validation des Conversions                            ‚îÇ
‚îÇ  ‚Ä¢ Isolation des Formats Externes                        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Organisation des Dossiers

### Structure Recommand√©e

```
src/
‚îú‚îÄ‚îÄ plans/                              # Domaine m√©tier "Plans"
‚îÇ   ‚îú‚îÄ‚îÄ domain/                         # üéØ Logique m√©tier pure
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ plan.operations.ts          # Operations pures (create, validate, etc.)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ plan.types.ts               # Types et sch√©mas Zod
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ plan.errors.ts              # Erreurs m√©tier typ√©es
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ plan-domain.service.ts      # Service m√©tier avec persistance
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ plan.repository.interface.ts # Contrat repository
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ application/                    # üéØ Coordination et orchestration
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ plan-application.service.ts # Service d'application
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ infrastructure/                 # üéØ D√©tails techniques
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ plan.repository.impl.ts     # Impl√©mentation repository
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ plan.adapter.ts             # Transformations DB ‚Üî Domain
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ plan.queries.ts             # Requ√™tes SQL/ORM complexes
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ presentation/                   # üéØ Interface API
‚îÇ       ‚îú‚îÄ‚îÄ plan.router.ts              # Routeur tRPC
‚îÇ       ‚îî‚îÄ‚îÄ plan.schemas.ts             # Sch√©mas de validation API
‚îÇ
‚îú‚îÄ‚îÄ fiches/                             # Autre domaine m√©tier
‚îÇ   ‚îú‚îÄ‚îÄ domain/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ fiche.operations.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ fiche.types.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ fiche-domain.service.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ fiche.repository.interface.ts
‚îÇ   ‚îú‚îÄ‚îÄ application/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ fiche-application.service.ts
‚îÇ   ‚îú‚îÄ‚îÄ infrastructure/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ fiche.repository.impl.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ fiche.adapter.ts
‚îÇ   ‚îî‚îÄ‚îÄ presentation/
‚îÇ       ‚îî‚îÄ‚îÄ fiche.router.ts
‚îÇ
‚îú‚îÄ‚îÄ shared/                             # Code partag√©
‚îÇ   ‚îú‚îÄ‚îÄ domain/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ base-errors.ts              # Erreurs communes
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ value-objects/              # Objets de valeur r√©utilisables
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ email.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ uuid.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ date-range.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ types.ts                    # Types communs
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ infrastructure/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ database.service.ts         # Service DB commun
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cache.service.ts            # Service cache
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ event-bus.service.ts        # Bus d'√©v√©nements
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ application/
‚îÇ       ‚îú‚îÄ‚îÄ permission.service.ts       # Service permissions
‚îÇ       ‚îî‚îÄ‚îÄ audit.service.ts            # Service audit
‚îÇ
‚îî‚îÄ‚îÄ app.module.ts                       # Configuration NestJS
```

### R√®gles d'Organisation

**üéØ Par Domaine M√©tier, Pas Par Type Technique**
```
‚úÖ BIEN                          ‚ùå MAL
src/plans/domain/               src/services/
src/plans/application/          src/repositories/
src/fiches/domain/              src/controllers/
```

**üéØ D√©pendances Claires**
- `presentation` ‚Üí `application` ‚Üí `domain`
- `infrastructure` ‚Üí `domain` (via interfaces)
- Jamais `domain` ‚Üí `infrastructure`

**üéØ Partage Intelligent**
- `shared/domain` : Objets de valeur, types communs
- `shared/infrastructure` : Services techniques
- `shared/application` : Services transversaux (permissions, audit)

## Matrice de D√©cision : O√π Mettre Cette Logique ?

### ü§î "Je dois impl√©menter cette fonctionnalit√©, o√π la mettre ?"

| **Crit√®re** | **Router** | **Application Service** | **Domain Service** | **Operations** |
|-------------|------------|------------------------|-------------------|----------------|
| **Validation des entr√©es API** | ‚úÖ Sch√©mas Zod | ‚ùå | ‚ùå | ‚ùå |
| **Authentification/Autorisation** | ‚úÖ Guards tRPC | ‚úÖ V√©rifications | ‚ùå | ‚ùå |
| **R√®gles m√©tier** | ‚ùå | ‚ùå | ‚úÖ Orchestration | ‚úÖ Pure |
| **Validation m√©tier** | ‚ùå | ‚ùå | ‚ùå | ‚úÖ |
| **Persistance simple** | ‚ùå | ‚ùå | ‚úÖ | ‚ùå |
| **Transactions complexes** | ‚ùå | ‚úÖ Multi-domaine | ‚úÖ Mono-domaine | ‚ùå |
| **Cache** | ‚ùå | ‚úÖ | ‚ùå | ‚ùå |
| **√âv√©nements** | ‚ùå | ‚úÖ | ‚ùå | ‚ùå |
| **Transformation API ‚Üî Domain** | ‚úÖ Simple | ‚úÖ Complexe | ‚ùå | ‚ùå |
| **Gestion d'erreurs HTTP** | ‚úÖ | ‚ùå | ‚ùå | ‚ùå |
| **Calculs m√©tier** | ‚ùå | ‚ùå | ‚úÖ Avec donn√©es | ‚úÖ Pure |
| **Coordination inter-services** | ‚ùå | ‚úÖ | ‚ùå | ‚ùå |

### üéØ Exemples Concrets

#### Exemple 1 : "Cr√©er un plan PCAET"
```typescript
// ‚úÖ Router : Validation API + gestion gracieuse des erreurs
input: createPlanSchema,
const result = await this.planApplicationService.createPlan(input, ctx.user);
if (!result.success) throw new TRPCError({...});

// ‚úÖ Application Service : Autorisation + coordination + effets de bord
const hasPermission = await this.permissionService.isAllowed(...);
const planResult = await this.planDomainService.createPlan(...);
await this.cacheService.invalidate(...);
await this.eventBus.publish(...);

// ‚úÖ Domain Service : Orchestration m√©tier + persistance
const validPlanResult = PlanOperations.create(input);
if (!validPlanResult.success) return validPlanResult;
const savedPlanResult = await this.planRepository.save(validPlanResult.value);
if (!savedPlanResult.success) return savedPlanResult;
const axesResult = await this.createDefaultAxes(savedPlanResult.value.id);

// ‚úÖ Operations : R√®gles m√©tier pures
if (input.type === 'PCAET' && !input.referents?.some(r => r.competence === 'ENERGIE')) {
  return failure(new MissingEnergyExpertise());
}
```

#### Exemple 2 : "Calculer le taux de completion d'un plan"
```typescript
// ‚úÖ Operations : Calcul pur
calculateCompletion: (plan: Plan, fiches: Fiche[]): number => {
  const totalFiches = fiches.length;
  const fichesCompleted = fiches.filter(f => f.statut === 'realise').length;
  return totalFiches > 0 ? (fichesCompleted / totalFiches) * 100 : 0;
}

// ‚úÖ Domain Service : R√©cup√©ration donn√©es + calcul
async getCompletionRate(planId: number): Promise<Result<number, DomainError>> {
  const planResult = await this.findPlanById(planId);
  if (!planResult.success) return planResult;
  
  const fichesResult = await this.findFichesByPlanId(planId);
  if (!fichesResult.success) return fichesResult;
  
    const completion = PlanOperations.calculateCompletion(planResult.value, fichesResult.value);
  return success(completion);
}
```

#### Exemple 3 : "Envoyer une notification lors de validation"
```typescript
// ‚ùå MAL : Dans Domain Service
class PlanDomainService {
  async validatePlan(planId: number) {
    // ... logique de validation
    await this.emailService.sendNotification(); // ‚ùå Effet de bord
  }
}

// ‚úÖ BIEN : Dans Application Service
class PlanApplicationService {
  async validatePlan(planId: number, user: User) {
    // Logique m√©tier d√©l√©gu√©e
    const result = await this.planDomainService.validatePlan(planId);
    
    // Effets de bord dans Application Service
    if (result.success) {
      await this.eventBus.publish(new PlanValidatedEvent({...}));
      await this.notificationService.notifyReferents(result.data);
    }
  }
}
```

### üö® Pi√®ges Courants √† √âviter

| **Pi√®ge** | **Pourquoi c'est mal** | **Solution** |
|-----------|----------------------|-------------|
| Logique m√©tier dans le Router | Couplage API ‚Üî Business | ‚Üí Application Service |
| Autorisation dans Domain Service | M√©lange concerns | ‚Üí Application Service |
| Cache dans Domain Service | Effet de bord technique | ‚Üí Application Service |
| SQL dans Application Service | Couplage technique | ‚Üí Repository |
| Validation API dans Domain | Couplage format externe | ‚Üí Router (sch√©mas Zod) |
| √âv√©nements dans Domain Service | Effet de bord | ‚Üí Application Service |

## R√®gles de D√©cision Simples

### O√π mettre cette logique ?

**üéØ Operations (Logique Pure)**
- ‚úÖ Validation des donn√©es d'entr√©e
- ‚úÖ R√®gles m√©tier qui ne n√©cessitent pas de persistance
- ‚úÖ Calculs et transformations m√©tier
- ‚úÖ Tout ce qui peut √™tre test√© sans d√©pendances

**üéØ Domain Service (Logique + Persistance)**
- ‚úÖ Orchestration d'objets m√©tier avec persistance
- ‚úÖ Workflows m√©tier complexes
- ‚úÖ Logique qui n√©cessite des donn√©es existantes
- ‚úÖ Transactions au niveau domaine

**üéØ Application Service (Coordination)**
- ‚úÖ Autorisation et permissions
- ‚úÖ Cache et optimisations
- ‚úÖ √âv√©nements et notifications
- ‚úÖ Transformations API ‚Üî Domaine
- ‚úÖ Coordination inter-domaines

## Gestion d'Erreurs avec le Pattern Result

### Pourquoi le Pattern Result ?

Notre codebase actuel souffre de gestion d'erreurs incoh√©rente :
- `throw new Error()` g√©n√©rique partout
- Impossible de distinguer erreurs m√©tier vs techniques
- Pas de typage des erreurs
- Debugging difficile

Le pattern Result r√©sout ces probl√®mes :

```typescript
// ‚ùå AVANT : Erreurs g√©n√©riques non typ√©es lanc√©es avec throw
async function createPlan(data) {
  if (!data.nom) throw new Error('Nom requis');
  if (data.type === 'PCAET' && !data.referents) throw new Error('R√©f√©rents requis');
  // ... impossible de savoir quelles erreurs peuvent survenir
}

// ‚úÖ APR√àS : Erreurs typ√©es et propag√©es via Result
function createPlan(data: CreatePlanData): Result<Plan, PlanDomainError> {
  // Toutes les erreurs possibles sont dans le type de retour
  // Pas d'exception lanc√©e, erreurs propag√©es explicitement
  // Le compilateur force √† les g√©rer
}
```

### Pattern d'Adoption Progressif

```typescript
// Type Result simple et r√©utilisable
type Result<T, E> = 
  | { success: true; value: T } 
  | { success: false; error: E };

// 1. Commencez par Result pour la logique pure
const result = PlanOperations.create(data);
if (!result.success) {
  // Gestion d'erreur explicite, pas d'exception
  console.error(result.error);
  return;
}
const plan = result.value;

// 2. Propagation dans les services avec async/await
async function createPlan(input: CreatePlanData): Promise<Result<Plan, DomainError>> {
  const validationResult = PlanOperations.create(input);
  if (!validationResult.success) {
    return validationResult; // Propagation sans throw
  }
  
  const saveResult = await repository.save(validationResult.value);
  return saveResult; // Pas d'exception lanc√©e
}

// 3. Gestion gracieuse dans le router (seul endroit o√π on throw si n√©cessaire)
const result = await planApplicationService.createPlan(request, user);
if (!result.success) {
  // Conversion en erreur HTTP appropri√©e
  throw new TRPCError({ code: 'BAD_REQUEST', message: result.error.message });
}
return result.value;
```

## √âtape 5 : Ajouter les Adapters (Transformation de Donn√©es)

**üí° TAKE #5** : Les objets m√©tier ne devraient jamais d√©pendre du format de la base de donn√©es. Les Adapters isolent ces transformations.

Dans notre refactoring, nous avons un probl√®me cach√© : notre `PlanDomainService` assume que les donn√©es DB correspondent exactement aux objets m√©tier. En r√©alit√©, il faut souvent transformer :

```typescript
// üî• PROBL√àME : Couplage DB ‚Üî Domain
class PlanDomainService {
  async createPlan(input: CreatePlanData): Promise<Result<Plan, DomainServiceError>> {
    const validationResult = PlanOperations.create(input);
    if (!validationResult.success) {
      return validationResult;
    }
    
    // ‚ùå On assume que l'objet m√©tier = format DB
    const savedPlanResult = await this.planRepository.save(validationResult.value, tx);
    return savedPlanResult;
  }
}
```

**Le probl√®me** : Notre base de donn√©es utilise `snake_case`, des IDs diff√©rents, et des formats de dates sp√©cifiques, mais notre domaine utilise `camelCase` et des types TypeScript stricts.

**La solution** : Cr√©er des Adapters qui transforment entre les formats :

```typescript
class AdapterError extends Error {
  readonly _tag = 'AdapterError';
  constructor(
    public readonly reason: string, 
    public readonly field?: string
  ) {
    super(`Adapter error: ${reason}${field ? ` (field: ${field})` : ''}`);
    this.name = 'AdapterError';
  }
}

// Types s√©par√©s : DB vs Domain
type PlanDbRow = {
  plan_id: number;
  plan_name: string;
  collectivite_id: number;
  plan_type: 'PAT' | 'PCAET' | 'AUTRE' | null;
  status_code: 'draft' | 'in_progress' | 'validated' | 'archived';
  created_at: string; // ISO string from DB
  created_by_user_id: string;
  referents_data: string; // JSON string
};

type Plan = {
  id: number;
  nom: string;
  collectiviteId: number;
  type: 'PAT' | 'PCAET' | 'AUTRE' | null;
  statut: 'brouillon' | 'en_cours' | 'valide' | 'archive';
  createdAt: Date;
  createdBy: string;
  referents: Array<{
    userId: string;
    nom: string;
    competence: 'ENERGIE' | 'TRANSPORT' | 'DECHETS' | 'AUTRE';
  }>;
};

// üéØ ADAPTER - Transformations isol√©es et testables
export const PlanAdapter = {
  // DB ‚Üí Domain
  toDomain: (dbRow: PlanDbRow): Result<Plan, AdapterError> => {
    try {
      // Mapping des statuts
      const statutMapping = {
        'draft': 'brouillon',
        'in_progress': 'en_cours', 
        'validated': 'valide',
        'archived': 'archive'
      } as const;

      // Parse JSON des r√©f√©rents
      let referents: Plan['referents'] = [];
      if (dbRow.referents_data) {
        referents = JSON.parse(dbRow.referents_data);
      }

      const domainPlan: Plan = {
        id: dbRow.plan_id,
        nom: dbRow.plan_name,
        collectiviteId: dbRow.collectivite_id,
        type: dbRow.plan_type,
        statut: statutMapping[dbRow.status_code],
        createdAt: new Date(dbRow.created_at),
        createdBy: dbRow.created_by_user_id,
        referents
      };

      return success(domainPlan);
    } catch (error) {
      return failure(new AdapterError(
          'Failed to convert DB row to domain object',
          error instanceof Error ? error.message : 'unknown'
        )
      );
    }
  },

  // Domain ‚Üí DB
  toDb: (plan: Plan): Result<PlanDbRow, AdapterError> => {
    try {
      // Mapping inverse des statuts
      const statusMapping = {
        'brouillon': 'draft',
        'en_cours': 'in_progress',
        'valide': 'validated', 
        'archive': 'archived'
      } as const;

      const dbRow: PlanDbRow = {
        plan_id: plan.id,
        plan_name: plan.nom,
        collectivite_id: plan.collectiviteId,
        plan_type: plan.type,
        status_code: statusMapping[plan.statut],
        created_at: plan.createdAt.toISOString(),
        created_by_user_id: plan.createdBy,
        referents_data: JSON.stringify(plan.referents)
      };

      return success(dbRow);
    } catch (error) {
      return failure(new AdapterError('Failed to convert domain object to DB row'));
    }
  }
};

// üéØ REPOSITORY avec Adapter int√©gr√©
@Injectable()
export class PlanRepository {
  constructor(private readonly db: DatabaseService) {}

  async save(plan: Plan, tx?: Transaction): Promise<Result<Plan, PersistenceError | AdapterError>> {
    // 1. Convertir Domain ‚Üí DB
    const dbRowResult = PlanAdapter.toDb(plan);
    if (!dbRowResult.success) {
      return dbRowResult;
    }

    // 2. Sauvegarder en DB
    try {
      const executor = tx || this.db;
      const [inserted] = await executor
        .insert(plansTable)
        .values(dbRowResult.value)
        .returning();
      const savedRow = inserted as PlanDbRow;

      // 3. Convertir DB ‚Üí Domain
      const domainResult = PlanAdapter.toDomain(savedRow);
      if (!domainResult.success) {
        return domainResult;
      }

      return domainResult;
    } catch (error) {
      return { 
        success: false, 
        error: new PersistenceError(error) 
      };
    }
  }

  async findById(id: number, tx?: Transaction): Promise<Result<Plan | null, PersistenceError | AdapterError>> {
    // 1. R√©cup√©rer de la DB
    try {
      const executor = tx || this.db;
      const dbRow = await executor
        .select()
        .from(plansTable)
        .where(eq(plansTable.plan_id, id))
        .limit(1)
        .then(rows => rows[0] || null);

      if (!dbRow) {
        return success(null);
      }

      // 2. Convertir DB ‚Üí Domain
      const domainResult = PlanAdapter.toDomain(dbRow);
      if (!domainResult.success) {
        return domainResult;
      }

      return domainResult;
    } catch (error) {
      return { 
        success: false, 
        error: new PersistenceError(error) 
      };
    }
  }
}
```

**üéØ R√©sultat de l'√âtape 5 :**
- ‚úÖ **Isolation compl√®te** : Le domaine ne conna√Æt pas le format DB
- ‚úÖ **Transformations explicites** : Mapping des statuts, formats de dates, etc.
- ‚úÖ **Testabilit√©** : Les adapters sont purs et facilement testables
- ‚úÖ **√âvolutivit√©** : Changer le sch√©ma DB n'impacte que l'adapter
- ‚úÖ **Gestion d'erreurs** : Les erreurs de transformation sont typ√©es

```typescript
// Test de l'adapter (trivial)
describe('PlanAdapter', () => {
  it('convertit correctement DB ‚Üí Domain', () => {
    const dbRow: PlanDbRow = {
      plan_id: 1,
      plan_name: 'Mon Plan PCAET',
      collectivite_id: 42,
      plan_type: 'PCAET',
      status_code: 'validated',
      created_at: '2024-01-15T10:30:00.000Z',
      created_by_user_id: 'user-123',
      referents_data: '[{"userId":"ref-1","nom":"Jean","competence":"ENERGIE"}]'
    };

    const result = PlanAdapter.toDomain(dbRow);
    
    expect(result.success).toBe(true);
    if (result.success) {
      expect(result.value.statut).toBe('valide'); // Mapping correct
      expect(result.value.createdAt).toBeInstanceOf(Date);
      expect(result.value.referents).toHaveLength(1);
    }
  });
});
```


# üèóÔ∏è Architecture Backend DDD - Proposition

## üìÅ Structure G√©n√©rale Propos√©e

```
src/
‚îú‚îÄ‚îÄ app.module.ts                           # Configuration NestJS racine
‚îú‚îÄ‚îÄ main.ts                                # Point d'entr√©e de l'application
‚îÇ
‚îú‚îÄ‚îÄ plans/                                 # üéØ DOMAINE : Plans d'action territoriaux
‚îÇ   ‚îú‚îÄ‚îÄ domain/                           # üß† Logique m√©tier pure
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ plan.aggregate.ts             # Plan comme racine d'agr√©gat
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ axe.entity.ts                 # Entit√© enfant : Axe
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ fiche.entity.ts               # Entit√© enfant : Fiche
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ budget.value-object.ts        # Objet de valeur : Budget
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ plan.operations.ts            # Op√©rations pures (create, validate, etc.)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ plan.types.ts                 # Types et sch√©mas Zod
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ plan.errors.ts                # Erreurs m√©tier typ√©es
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ plan-domain.service.ts        # Service m√©tier avec persistance
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ plan.repository.interface.ts  # Contrat repository
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ application/                      # üéØ Coordination et orchestration
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ plan-application.service.ts   # Service d'application principal
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ plan-import.service.ts        # Service d'import (use case sp√©cifique)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ plan-export.service.ts        # Service d'export (use case sp√©cifique)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ plan-analytics.service.ts     # Service analytics cross-domaine
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ infrastructure/                   # üîß D√©tails techniques
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ plan.repository.impl.ts       # Impl√©mentation repository
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ plan.adapter.ts               # Transformations DB ‚Üî Domain
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ plan.queries.ts               # Requ√™tes SQL/ORM complexes
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ plan.tables.ts                # D√©finitions tables Drizzle
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ external/                     # Services externes
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ plan-export.client.ts     # Client pour export externe
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ plan-notification.client.ts # Client notifications
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ presentation/                     # üåê Interface API
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ plan.router.ts                # Routeur tRPC principal
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ plan.schemas.ts               # Sch√©mas validation API
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ plan.controller.ts            # Controller REST (si n√©cessaire)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ dto/                          # DTOs pour API
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ create-plan.dto.ts
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ update-plan.dto.ts
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ plan-response.dto.ts
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ tests/                            # üß™ Tests du domaine
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ unit/                         # Tests unitaires (domain, operations)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ integration/                  # Tests d'int√©gration (services)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ e2e/                          # Tests end-to-end (API)
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ plans.module.ts                   # Module NestJS du domaine
‚îÇ   ‚îî‚îÄ‚îÄ index.ts                          # Exports publics
‚îÇ
‚îú‚îÄ‚îÄ indicateurs/                          # üéØ DOMAINE : Indicateurs et m√©triques
‚îÇ   ‚îú‚îÄ‚îÄ ...
## Cons√©quences de cette Architecture

### B√©n√©fices

**1. Testabilit√© Am√©lior√©e**
- Logique m√©tier testable unitairement sans aucune d√©pendance
- Tests plus rapides et plus fiables
- Coverage m√©tier plus facilement atteignable

**2. Maintenabilit√© et √âvolutivit√©**
- R√®gles m√©tier centralis√©es et plus faciles √† modifier
- R√©utilisation de la logique m√©tier dans diff√©rents contextes

**3. Gestion d'Erreurs Plus Robuste**
- Erreurs typ√©es et explicites
- Debugging facilit√© avec des erreurs contextualis√©es
- R√©duction des exceptions inattendues en production

**4. S√©paration des Pr√©occupations Plus Claire**
- Chaque couche a une responsabilit√© bien d√©finie
- Modifications plus isol√©es avec moins d'effets de bord
- Code plus lisible et plus compr√©hensible

**5. Adoption Graduelle**
- Migration service par service sans casser l'existant
- Approche progressive, risque ma√Ætris√©
- ROI visible d√®s le premier service migr√©

### Co√ªts

**1. Nombre de Fichiers Accru**
- 1 service devient 3-4 fichiers (Operations, Domain Service, Application Service)
- Structure de dossiers plus complexe

**2. Courbe d'Apprentissage**
- Effect-TS n√©cessite une mont√©e en comp√©tences
- Concepts DDD √† assimiler
- Nouveaux patterns √† ma√Ætriser

**3. Overhead Initial**
- Setup plus long pour les nouveaux services
- Plus de boilerplate au d√©but


## üö® D√©tecter les Mauvaises Fronti√®res de Domaine

### Application Services : R√©v√©lateurs de Probl√®mes de Domaine

Votre Application Service vous dit si vos domaines sont mal d√©coup√©s. Voici les signaux d'alarme :

### **üî¥ RED FLAG #1 : Coordination Syst√©matique**

```typescript
// PROBL√àME : Toujours les m√™mes services ensemble
@Injectable()
export class PlanApplicationService {
  
  async createPlan() {
    const plan = await this.planDomainService.createPlan();
    const axes = await this.axeDomainService.createDefaultAxes(plan.id);     // Toujours
    const fiches = await this.ficheDomainService.createDefaultFiches(plan.id); // Toujours
    return { plan, axes, fiches };
  }

  async updatePlan() {
    const plan = await this.planDomainService.updatePlan();
    await this.axeDomainService.reorderAxes(plan.id);                       // Toujours
    await this.ficheDomainService.updateFichesStructure(plan.id);           // Toujours
    return plan;
  }

  async deletePlan() {
    await this.ficheDomainService.deleteAllFiches(plan.id);                 // Toujours
    await this.axeDomainService.deleteAllAxes(plan.id);                     // Toujours  
    await this.planDomainService.deletePlan(plan.id);
  }
}

// DIAGNOSTIC : Si vous coordonnez TOUJOURS les m√™mes services
// ‚Üí C'est probablement UN SEUL domaine m√©tier
```

#### **üí° SOLUTION pour Red Flag #1 : Unifier en Agr√©gat**

```typescript
// SOLUTION : Domaine unifi√© avec Plan comme racine d'agr√©gat
@Injectable()
export class PlanDomainService {
  
  // Une seule op√©ration qui g√®re tout l'agr√©gat
  async createCompletePlan(
    planData: CreatePlanData,
    tx?: Transaction
  ): Promise<Result<Plan, DomainError>> {
    // Validation de l'agr√©gat complet
    const planResult = PlanOperations.create({
      ...planData,
      createDefaultStructure: true
    });
    if (!planResult.success) {
      return planResult;
    }
    
    // Sauvegarde atomique de tout l'agr√©gat
    const savedPlanResult = await this.planRepository.save(planResult.value, tx);
    if (!savedPlanResult.success) {
      return savedPlanResult;
    }
    
    return savedPlanResult;
  }
  
  // Plus besoin de coordonner : tout est dans le m√™me agr√©gat
  async updatePlanStructure(
    planId: number,
    updates: UpdatePlanStructureData,
    tx?: Transaction
  ): Promise<Result<Plan, DomainError>> {
    const planResult = await this.planRepository.findById(planId, tx);
    if (!planResult.success) {
      return planResult;
    }
    
    const plan = planResult.value;
    if (!plan) {
      return failure(new PlanNotFound(planId));
    }
    
    // Logique m√©tier unifi√©e dans l'agr√©gat
    const updatedPlanResult = plan.updateStructure(updates);
    if (!updatedPlanResult.success) {
      return updatedPlanResult;
    }
    
    const savedPlanResult = await this.planRepository.save(updatedPlanResult.value, tx);
    if (!savedPlanResult.success) {
      return savedPlanResult;
    }
    
    return savedPlanResult;
  }
}

// Mod√®le de domaine unifi√©
export class Plan {
  constructor(
    public readonly id: number,
    public readonly nom: string,
    public readonly type: PlanType,
    public readonly collectiviteId: number,
    public readonly axes: Axe[],          // Entit√©s enfants
    public readonly fiches: Fiche[],      // Entit√©s enfants
    public readonly statut: PlanStatus
  ) {}
  
  // Logique m√©tier centralis√©e
  updateStructure(updates: UpdatePlanStructureData): Result<Plan, DomainError> {
    // Validation globale de la coh√©rence
    if (updates.axes && updates.fiches) {
      const isCoherent = this.validateAxesFichesCoherence(updates.axes, updates.fiches);
      if (!isCoherent) {
        return failure(new IncoherentStructureError());
      }
    }
    
    return success(new Plan(
        this.id,
        updates.nom ?? this.nom,
        updates.type ?? this.type,
        this.collectiviteId,
        updates.axes ?? this.axes,
        updates.fiches ?? this.fiches,
        this.statut
      )
    };
  }
  
  private validateAxesFichesCoherence(axes: Axe[], fiches: Fiche[]): boolean {
    // R√®gle m√©tier : toutes les fiches doivent avoir un axe valide
    return fiches.every(fiche => 
      axes.some(axe => axe.id === fiche.axeId)
    );
  }
}
```

### **üî¥ RED FLAG #2 : Transaction Boundaries Partout**

```typescript
// PROBL√àME : Toutes les op√©rations n√©cessitent des transactions cross-services
@Injectable() 
export class PlanApplicationService {

  async createPlan() {
    return this.db.transaction(async (tx) => {
      const plan = await this.planDomainService.createPlan(data, tx);
      const axes = await this.axeDomainService.createAxes(plan.id, tx);     // M√™me transaction
      const fiches = await this.ficheDomainService.createFiches(plan.id, tx); // M√™me transaction
      // Toujours dans la m√™me transaction = m√™me agr√©gat !
    });
  }

  async updatePlanStructure() {
    return this.db.transaction(async (tx) => {
      await this.planDomainService.updatePlan(data, tx);
      await this.axeDomainService.restructureAxes(planId, tx);              // M√™me transaction
      await this.ficheDomainService.reassignFiches(planId, tx);             // M√™me transaction
    });
  }
}

// DIAGNOSTIC : Si vos op√©rations m√©tier n√©cessitent TOUJOURS des transactions cross-services
// ‚Üí Ces services g√®rent le m√™me agr√©gat m√©tier
```

#### **üí° SOLUTION pour Red Flag #2 : Transactions Intra-Agr√©gat**

```typescript
// SOLUTION : Une seule transaction par agr√©gat
@Injectable()
export class PlanDomainService {
  
  // Transaction unique pour l'agr√©gat complet
  async createPlanWithStructure(
    request: CreatePlanRequest,
    tx?: Transaction
  ): Promise<Result<Plan, DomainError>> {
    // Tout se passe dans le m√™me agr√©gat = une seule transaction
    const planResult = PlanAggregate.create({
      nom: request.nom,
      type: request.type,
      collectiviteId: request.collectiviteId,
      defaultAxes: request.createDefaultStructure ? 
        PlanOperations.getDefaultAxesForType(request.type) : [],
      defaultFiches: request.createDefaultStructure ?
          PlanOperations.getDefaultFichesForType(request.type) : []
    });
    
    if (!planResult.success) {
      return planResult;
    }
    
    // Une seule sauvegarde atomique
    const savedPlanResult = await this.planRepository.save(planResult.value, tx);
    if (!savedPlanResult.success) {
      return savedPlanResult;
    }
    
    return savedPlanResult;
  }
}

// Agr√©gat qui g√®re sa propre coh√©rence
export class PlanAggregate {
  
  static create(data: CreatePlanData): Result<PlanAggregate, DomainError> {
    // Validation de coh√©rence globale √† la cr√©ation
    if (data.type === 'PCAET') {
      if (data.defaultAxes.length < 3) {
        return failure(new InvalidPcaetStructure('PCAET needs at least 3 axes'));
      }
    }
    
    // Validation des relations axes-fiches
    const ficheAxeIds = data.defaultFiches.map(f => f.axeId);
    const axeIds = data.defaultAxes.map(a => a.id);
    const hasOrphanFiches = ficheAxeIds.some(id => !axeIds.includes(id));
    
    if (hasOrphanFiches) {
      return failure(new OrphanFichesError());
    }
    
    return success(new PlanAggregate(
        data.nom,
        data.type,
        data.collectiviteId,
        data.defaultAxes,
        data.defaultFiches,
        'brouillon'
      )
    };
  }
  
  // Op√©rations qui maintiennent la coh√©rence interne
  addAxe(axe: Axe): Result<PlanAggregate, DomainError> {
    // Validation des r√®gles m√©tier internes
    if (this.axes.some(a => a.nom === axe.nom)) {
      return failure(new DuplicateAxeError(axe.nom));
    }
    
    return success(new PlanAggregate(
        this.nom,
        this.type,
        this.collectiviteId,
        [...this.axes, axe],
        this.fiches,
        this.statut
      )
    };
  }
  
  removeAxe(axeId: number): Result<PlanAggregate, DomainError> {
    // Gestion des d√©pendances internes
    const dependentFiches = this.fiches.filter(f => f.axeId === axeId);
    if (dependentFiches.length > 0) {
      return failure(new AxeHasDependentFichesError(axeId, dependentFiches.length));
    }
    
    return success(new PlanAggregate(
        this.nom,
        this.type,
        this.collectiviteId,
        this.axes.filter(a => a.id !== axeId),
        this.fiches,
        this.statut
      )
    };
  }
}

// Application Service simplifi√© - plus de transactions cross-services
@Injectable()
export class PlanApplicationService {
  
  async createPlan(request: CreatePlanRequest, user: AuthenticatedUser) {
    // Autorisation
    const hasPermission = await this.permissionService.isAllowed(user, 'PLANS.CREATE', request.collectiviteId);
    if (!hasPermission) {
      return failure(new Forbidden('Unauthorized'));
    }
    
    // Une seule transaction pour tout l'agr√©gat
    const result = await this.db.transaction(async (tx) => {
      const planResult = await this.planDomainService.createPlanWithStructure(request, tx);
      if (!planResult.success) {
        throw planResult.error; // Rollback transaction
      }
      return planResult.value;
    });
    
    // Effets de bord
    await this.eventBus.publish(new PlanCreatedEvent({ planId: result.id }));
    
    return success(result);
  }
}
```

### **üî¥ RED FLAG #3 : Logique M√©tier dans l'Application Service**

```typescript
// PROBL√àME : L'Application Service contient de la logique m√©tier
@Injectable()
export class PlanApplicationService {

  async validatePlan(planId: number) {
    const plan = await this.planDomainService.findById(planId);
    const fiches = await this.ficheDomainService.findByPlanId(planId);
    
    // R√®gle m√©tier dans l'Application Service
    if (plan.type === 'PCAET' && fiches.length < 3) {
      throw new Error('Un PCAET doit avoir au moins 3 fiches');
    }
    
    // Calcul m√©tier dans l'Application Service
    const completion = fiches.filter(f => f.statut === 'realise').length / fiches.length;
    if (completion < 0.8) {
      throw new Error('Le plan doit √™tre compl√©t√© √† 80%');
    }
    
    return this.planDomainService.markAsValidated(planId);
  }
}

// DIAGNOSTIC : Si l'Application Service conna√Æt les r√®gles m√©tier
// ‚Üí Ces objets appartiennent au m√™me domaine
```

#### **üí° SOLUTION pour Red Flag #3 : D√©placer la Logique vers le Domaine**

```typescript
// SOLUTION : Logique m√©tier dans le domaine, coordination dans l'Application Service
@Injectable()
export class PlanApplicationService {

  async validatePlan(planId: number, user: AuthenticatedUser) {
    // Autorisation (Application concern)
    const hasPermission = await this.permissionService.isAllowed(user, 'PLANS.VALIDATE', planId);
    if (!hasPermission) {
      return failure(new Forbidden('Unauthorized'));
    }
    
    // D√©l√©gation au domaine pour la logique m√©tier
    const validationResult = await this.planDomainService.validatePlan(planId);
    
    if (!validationResult.success) {
      return validationResult; // Propagation des erreurs m√©tier
    }
    
    const validatedPlan = validationResult.value;
    
    // Effets de bord (Application concern)
    await Promise.all([
      this.eventBus.publish(new PlanValidatedEvent({ planId: validatedPlan.id })),
      this.auditService.logPlanValidation(planId, user.id),
      this.cacheService.invalidate(`plan:${planId}`)
    ]);
    
    return success(validatedPlan);
  }
}

// Logique m√©tier centralis√©e dans le domaine
@Injectable()
export class PlanDomainService {
  
  async validatePlan(planId: number): Promise<Result<Plan, DomainError>> {
    const planResult = await this.planRepository.findById(planId);
    if (!planResult.success) {
      return planResult;
    }
    
    const plan = planResult.value;
    if (!plan) {
      return failure(new PlanNotFound(planId));
    }
    
    // D√©l√©gation √† l'agr√©gat pour les r√®gles m√©tier
    const validationResult = plan.validate();
    if (!validationResult.success) {
      return validationResult;
    }
    
    // Sauvegarde du nouveau statut
    const savedPlanResult = await this.planRepository.save(validationResult.value);
    if (!savedPlanResult.success) {
      return savedPlanResult;
    }
    
    return savedPlanResult;
  }
}

// ‚úÖ R√®gles m√©tier dans l'agr√©gat
export class Plan {
  
  validate(): Result<Plan, DomainError> {
    // R√®gle m√©tier : validation sp√©cifique par type
    if (this.type === 'PCAET') {
      const pcaetValidation = this.validatePcaetRules();
      if (!pcaetValidation.success) {
        return pcaetValidation;
      }
    }
    
    // R√®gle m√©tier : calcul de compl√©tude
    const completion = this.calculateCompletion();
    if (completion < 0.8) {
      return { 
        success: false, 
        error: new InsufficientCompletionError(completion, 0.8)
      };
    }
    
    // Transition d'√©tat valide
    if (this.statut !== 'brouillon' && this.statut !== 'en_cours') {
      return { 
        success: false, 
        error: new InvalidStatusTransitionError(this.statut, 'valide')
      };
    }
    
    return { 
      success: true, 
      value: new Plan(
        this.id,
        this.nom,
        this.type,
        this.collectiviteId,
        this.axes,
        this.fiches,
        'valide' // Nouveau statut
      )
    };
  }
  
  private validatePcaetRules(): Result<void, DomainError> {
    // R√®gle m√©tier PCAET : au moins 3 fiches
    if (this.fiches.length < 3) {
      return { 
        success: false, 
        error: new InsufficientPcaetFichesError(this.fiches.length, 3)
      };
    }
    
    // R√®gle m√©tier PCAET : au moins un axe "√©nergie"
    const hasEnergyAxe = this.axes.some(axe => 
      axe.nom.toLowerCase().includes('√©nergie') || 
      axe.nom.toLowerCase().includes('energie')
    );
    
    if (!hasEnergyAxe) {
      return failure(new MissingEnergyAxeError());
    }
    
    return success(undefined);
  }
  
  private calculateCompletion(): number {
    if (this.fiches.length === 0) return 0;
    
    const completedFiches = this.fiches.filter(fiche => 
      fiche.statut === 'realise' || fiche.statut === 'valide'
    ).length;
    
    return completedFiches / this.fiches.length;
  }
}
```

### **üî¥ RED FLAG #4 : Services qui se Connaissent Trop**

```typescript
// PROBL√àME : Les Domain Services se connaissent indirectement
@Injectable()
export class FicheDomainService {
  
  async updateFiche(ficheId: number, updates: UpdateFicheData) {
    const fiche = await this.ficheRepository.findById(ficheId);
    
    // Le FicheService conna√Æt les r√®gles du Plan
    const plan = await this.planDomainService.findById(fiche.planId);
    if (plan.statut === 'archive') {
      throw new Error('Cannot modify fiche in archived plan');
    }
    
    // Le FicheService conna√Æt la structure des Axes
    const axe = await this.axeDomainService.findById(fiche.axeId);
    if (axe.type === 'OBLIGATOIRE' && updates.statut === 'abandonne') {
      throw new Error('Cannot abandon mandatory axe fiche');
    }
    
    return this.ficheRepository.save({ ...fiche, ...updates });
  }
}

// DIAGNOSTIC : Si un Domain Service conna√Æt les r√®gles d'autres "domaines"
// ‚Üí C'est le m√™me domaine m√©tier
```

#### **üí° SOLUTION pour Red Flag #4 : Encapsulation dans l'Agr√©gat**

```typescript
// SOLUTION : Toute la logique inter-entit√©s dans l'agr√©gat
export class Plan {
  
  // Encapsulation : les r√®gles inter-entit√©s restent dans l'agr√©gat
  updateFiche(ficheId: number, updates: UpdateFicheData): Result<Plan, DomainError> {
    const ficheIndex = this.fiches.findIndex(f => f.id === ficheId);
    if (ficheIndex === -1) {
      return failure(new FicheNotFoundError(ficheId));
    }
    
    const currentFiche = this.fiches[ficheIndex];
    
    // R√®gle m√©tier : impossible de modifier une fiche si le plan est archiv√©
    if (this.statut === 'archive') {
      return failure(new CannotModifyArchivedPlanError(this.id));
    }
    
    // R√®gle m√©tier : validation des transitions d'axe
    if (updates.axeId && updates.axeId !== currentFiche.axeId) {
      const targetAxe = this.axes.find(a => a.id === updates.axeId);
      if (!targetAxe) {
        return failure(new AxeNotFoundError(updates.axeId));
      }
      
      // R√®gle m√©tier : impossible d'abandonner une fiche d'axe obligatoire
      if (targetAxe.type === 'OBLIGATOIRE' && updates.statut === 'abandonne') {
        return failure(new CannotAbandonMandatoryAxeFicheError(targetAxe.id));
      }
    }
    
    // Mise √† jour coh√©rente
    const updatedFiches = [...this.fiches];
    updatedFiches[ficheIndex] = { ...currentFiche, ...updates };
    
    return success(new Plan(
        this.id,
        this.nom,
        this.type,
        this.collectiviteId,
        this.axes,
        updatedFiches,
        this.statut
      )
    };
  }
  
  // Encapsulation : gestion des d√©pendances internes
  removeAxe(axeId: number): Result<Plan, DomainError> {
    const axeIndex = this.axes.findIndex(a => a.id === axeId);
    if (axeIndex === -1) {
      return failure(new AxeNotFoundError(axeId));
    }
    
    // Gestion des d√©pendances : r√©assignation automatique des fiches
    const dependentFiches = this.fiches.filter(f => f.axeId === axeId);
    const defaultAxe = this.axes.find(a => a.type === 'DEFAULT');
    
    if (dependentFiches.length > 0 && !defaultAxe) {
      return failure(new CannotRemoveAxeWithoutDefaultError(axeId));
    }
    
    // R√©assignation automatique
    const updatedFiches = this.fiches.map(fiche => 
      fiche.axeId === axeId 
        ? { ...fiche, axeId: defaultAxe!.id }
        : fiche
    );
    
    const updatedAxes = this.axes.filter(a => a.id !== axeId);
    
    return success(new Plan(
        this.id,
        this.nom,
        this.type,
        this.collectiviteId,
        updatedAxes,
        updatedFiches,
        this.statut
      )
    };
  }
}

// Domain Service simplifi√© - plus de connaissances cross-domaines
@Injectable()
export class PlanDomainService {
  
  async updateFiche(
    planId: number,
    ficheId: number,
    updates: UpdateFicheData,
    tx?: Transaction
  ): Promise<Result<Plan, DomainError>> {
    // R√©cup√©ration de l'agr√©gat complet
    const planResult = await this.planRepository.findById(planId, tx);
    if (!planResult.success) {
      return planResult;
    }
    
    const plan = planResult.value;
    if (!plan) {
      return failure(new PlanNotFound(planId));
    }
    
    // D√©l√©gation √† l'agr√©gat pour toute la logique m√©tier
    const updatedPlanResult = plan.updateFiche(ficheId, updates);
    if (!updatedPlanResult.success) {
      return updatedPlanResult;
    }
    
    // Sauvegarde atomique
    const savedPlanResult = await this.planRepository.save(updatedPlanResult.value, tx);
    if (!savedPlanResult.success) {
      return savedPlanResult;
    }
    
    return savedPlanResult;
  }
}
```

### **üî¥ RED FLAG #5 : Pas d'Op√©rations Ind√©pendantes**

```typescript
// PROBL√àME : Aucune op√©ration ne peut √™tre faite de mani√®re isol√©e
@Injectable()
export class AxeDomainService {
  
  // Impossible de cr√©er un axe sans plan
  async createAxe(data: CreateAxeData) {
    // Doit toujours v√©rifier le plan parent
    const plan = await this.planDomainService.findById(data.planId);
    // ...
  }
  
  // Impossible de supprimer un axe sans impacter les fiches
  async deleteAxe(axeId: number) {
    // Doit toujours g√©rer les fiches li√©es
    await this.ficheApplicationService.reassignFichesFromAxe(axeId);
    // ...
  }
}

// DIAGNOSTIC : Si aucune op√©ration ne peut √™tre faite de mani√®re ind√©pendante
// ‚Üí Ces objets forment un seul agr√©gat
```

#### **üí° SOLUTION pour Red Flag #5 : Agr√©gat Root Unique**

```typescript
// SOLUTION : Un seul point d'entr√©e via l'agr√©gat root
@Injectable()
export class PlanDomainService {
  
  // Toutes les op√©rations passent par l'agr√©gat root
  async createAxe(
    planId: number,
    axeData: CreateAxeData,
    tx?: Transaction
  ): Promise<Result<Plan, DomainError>> {
    // R√©cup√©ration de l'agr√©gat complet
    const planResult = await this.planRepository.findById(planId, tx);
    if (!planResult.success) {
      return planResult;
    }
    
    const plan = planResult.value;
    if (!plan) {
      return failure(new PlanNotFound(planId));
    }
    
    // L'agr√©gat g√®re sa propre coh√©rence
    const updatedPlanResult = plan.addAxe(axeData);
    if (!updatedPlanResult.success) {
      return updatedPlanResult;
    }
    
    // Sauvegarde atomique
    const savedPlanResult = await this.planRepository.save(updatedPlanResult.value, tx);
    if (!savedPlanResult.success) {
      return savedPlanResult;
    }
    
    return savedPlanResult;
  }
  
  // Suppression d'axe avec gestion automatique des d√©pendances
  async removeAxe(
    planId: number,
    axeId: number,
    tx?: Transaction
  ): Promise<Result<Plan, DomainError>> {
    const planResult = await this.planRepository.findById(planId, tx);
    if (!planResult.success) {
      return planResult;
    }
    
    const plan = planResult.value;
    if (!plan) {
      return failure(new PlanNotFound(planId));
    }
    
    // L'agr√©gat g√®re les d√©pendances internes automatiquement
    const updatedPlanResult = plan.removeAxe(axeId);
    if (!updatedPlanResult.success) {
      return updatedPlanResult;
    }
    
    const savedPlanResult = await this.planRepository.save(updatedPlanResult.value, tx);
    if (!savedPlanResult.success) {
      return savedPlanResult;
    }
    
    return savedPlanResult;
  }
}

// Agr√©gat qui garantit la coh√©rence interne
export class Plan {
  
  addAxe(axeData: CreateAxeData): Result<Plan, DomainError> {
    // Validation autonome (pas besoin de v√©rifier d'autres services)
    if (this.axes.some(a => a.nom === axeData.nom)) {
      return failure(new DuplicateAxeError(axeData.nom));
    }
    
    // R√®gles m√©tier internes
    if (this.statut === 'archive') {
      return failure(new CannotModifyArchivedPlanError(this.id));
    }
    
    const newAxe = new Axe(
      this.generateAxeId(),
      axeData.nom,
      axeData.type || 'STANDARD',
      this.axes.length + 1 // ordre automatique
    );
    
    return success(new Plan(
        this.id,
        this.nom,
        this.type,
        this.collectiviteId,
        [...this.axes, newAxe],
        this.fiches,
        this.statut
      )
    };
  }
  
  removeAxe(axeId: number): Result<Plan, DomainError> {
    const axeToRemove = this.axes.find(a => a.id === axeId);
    if (!axeToRemove) {
      return failure(new AxeNotFoundError(axeId));
    }
    
    // Gestion automatique des d√©pendances (plus besoin d'autres services)
    const dependentFiches = this.fiches.filter(f => f.axeId === axeId);
    const defaultAxe = this.axes.find(a => a.type === 'DEFAULT');
    
    if (dependentFiches.length > 0) {
      if (!defaultAxe) {
        return failure(new CannotRemoveAxeWithoutDefaultError(axeId));
      }
      
      // R√©assignation automatique des fiches
      const reassignedFiches = this.fiches.map(fiche =>
        fiche.axeId === axeId
          ? { ...fiche, axeId: defaultAxe.id }
          : fiche
      );
      
      const remainingAxes = this.axes.filter(a => a.id !== axeId);
      
      return { 
        success: true, 
        value: new Plan(
          this.id,
          this.nom,
          this.type,
          this.collectiviteId,
          remainingAxes,
          reassignedFiches,
          this.statut
        )
      };
    }
    
    // Suppression simple si pas de d√©pendances
    const remainingAxes = this.axes.filter(a => a.id !== axeId);
    
    return { 
      success: true, 
      value: new Plan(
        this.id,
        this.nom,
        this.type,
        this.collectiviteId,
        remainingAxes,
        this.fiches,
        this.statut
      )
    };
  }
  
  // Op√©rations autonomes possibles
  canAddAxe(): boolean {
    return this.statut !== 'archive' && this.axes.length < 10; // Limite m√©tier
  }
  
  canRemoveAxe(axeId: number): boolean {
    const axe = this.axes.find(a => a.id === axeId);
    return axe?.type !== 'OBLIGATOIRE' && this.statut !== 'archive';
  }
  
  private generateAxeId(): number {
    return Math.max(...this.axes.map(a => a.id), 0) + 1;
  }
}

// Plus de services s√©par√©s - tout passe par l'agr√©gat
// Pas de AxeDomainService, FicheDomainService s√©par√©s
// = Coh√©rence garantie, op√©rations atomiques, r√®gles centralis√©es
```

### **√Ä Quoi Ressemble un Application Service Bien Con√ßu**

```typescript
// Application Service qui coordonne des domaines vraiment ind√©pendants
@Injectable()
export class PlanningApplicationService {
  
  async createCompletePlan(request: CreatePlanRequest) {
    
    // Autorisation (Application concern)
    await this.checkPermissions(request.collectiviteId, user);
    
    return this.db.transaction(async (tx) => {
      
      // 1. Domaine Plan : Gestion du plan d'action
      const plan = await this.planDomainService.createPlan({
        nom: request.planName,
        type: request.planType,
        collectiviteId: request.collectiviteId
      }, tx);
      
      // 2. Domaine Budget : Allocation budg√©taire (vraiment ind√©pendant)
      const budget = await this.budgetDomainService.allocateBudget({
        planId: plan.id,
        amount: request.totalBudget,
        year: request.year
      }, tx);
      
      // 3. Domaine Communication : Plan de communication (vraiment ind√©pendant)  
      const communication = await this.communicationDomainService.createCampaign({
        planId: plan.id,
        channels: request.communicationChannels,
        timeline: request.timeline
      }, tx);
      
      // Effets de bord
      await this.eventBus.publish(new PlanCreated({ planId: plan.id }));
      
      return { plan, budget, communication };
    });
  }
}

// Chaque domaine peut √©voluer ind√©pendamment
// - Changer les r√®gles budg√©taires n'impacte pas les plans
// - Modifier la communication n'impacte pas le budget
// - Seule la coordination change quand on ajoute/retire des domaines
```

### **Autre Exemple : Service d'Analytics Cross-Domaine**

```typescript
// Service d'analytics qui agr√®ge des donn√©es de plusieurs domaines
@Injectable()
export class TerritorialAnalyticsApplicationService {
  
  async generateCompletionReport(
    collectiviteId: number,
    period: DateRange,
    user: AuthenticatedUser
  ): Promise<Result<CompletionReportResponse, ApplicationError>> {
    
    // Autorisation
    const hasPermission = await this.permissionService.isAllowed(
      user, 'ANALYTICS.READ', collectiviteId
    );
    if (!hasPermission) {
      return failure(new Forbidden('Unauthorized'));
    }
    
    // Agr√©gation de donn√©es de diff√©rents domaines
    const [plansData, budgetData, indicateursData] = await Promise.all([
      // Chaque domaine expose ses propres m√©triques
      this.planDomainService.getCompletionMetrics(collectiviteId, period),
      this.budgetDomainService.getBudgetUtilization(collectiviteId, period),
      this.indicateurDomainService.getProgressMetrics(collectiviteId, period)
    ]);
    
    // Calculs d'analytics (logique d'application, pas de domaine)
    const globalCompletion = this.calculateGlobalCompletion(plansData, budgetData);
    const trends = this.calculateTrends(indicateursData, period);
    const recommendations = this.generateRecommendations(globalCompletion, trends);
    
    return { 
      success: true, 
      value: {
        collectiviteId,
        period,
        globalCompletion,
        trends,
        recommendations,
        details: {
          plans: plansData,
          budget: budgetData,
          indicateurs: indicateursData
        }
      }
    };
  }
  
  // Logique d'analytics (coordination, pas m√©tier)
  private calculateGlobalCompletion(plans: PlanMetrics[], budget: BudgetMetrics): number {
    // Calcul cross-domaine pour analytics
    const planWeight = 0.6;
    const budgetWeight = 0.4;
    
    return (plans.averageCompletion * planWeight) + (budget.utilizationRate * budgetWeight);
  }
  
  private calculateTrends(indicateurs: IndicateurMetrics[], period: DateRange): TrendAnalysis {
    // Analyse de tendances (logique d'analytics, pas de domaine)
    return {
      direction: indicateurs.length > 0 ? 'improving' : 'stable',
      velocity: this.calculateVelocity(indicateurs, period),
      predictions: this.predictFutureValues(indicateurs)
    };
  }
}

// POURQUOI CETTE APPROCHE FONCTIONNE :
// - Chaque domaine reste ind√©pendant (Plans, Budget, Indicateurs)
// - L'analytics est une pr√©occupation d'APPLICATION (reporting cross-domaine)
// - Les domaines exposent leurs m√©triques sans conna√Ætre les autres
// - L'analytics peut √©voluer sans impacter les domaines m√©tier
// - C'est de la coordination l√©gitime, pas de la logique m√©tier
```

### **üéØ Comment Distinguer Analytics L√©gitime vs Mauvais Domaines**

| **Crit√®re** | **Analytics L√©gitime** | **Mauvais D√©coupage** |
|-------------|------------------------|------------------------|
| **Nature de la logique** | Agr√©gation, calculs de reporting | R√®gles m√©tier, validation |
| **D√©pendances** | Lecture seule des m√©triques | Modification des donn√©es m√©tier |
| **√âvolution** | Analytics change ind√©pendamment | Domaines li√©s √©voluent ensemble |
| **Expertise** | Analyste/Data, pas expert m√©tier | M√™me expert m√©tier pour tous |
| **Transactions** | Pas de transactions cross-domaine | Transactions syst√©matiques |
| **R√©utilisabilit√©** | R√©utilisable pour diff√©rents contextes | Sp√©cifique √† un workflow |

```typescript
// ANALYTICS APPROPRI√â
class AnalyticsService {
  // Agr√®ge des donn√©es existantes
  async getGlobalMetrics() {
    const planMetrics = await this.planService.getMetrics();     // Lecture seule
    const budgetMetrics = await this.budgetService.getMetrics(); // Lecture seule
    return this.aggregateMetrics(planMetrics, budgetMetrics);    // Calcul d'analytics
  }
}

// D√âCOUPAGE PROBL√âMATIQUE
class PlanApplicationService {
  // Modifie toujours les m√™mes objets ensemble
  async createPlan() {
    const plan = await this.planService.create();     // Toujours
    const axes = await this.axeService.create();      // Toujours  
    const fiches = await this.ficheService.create();  // Toujours
    // = M√™me domaine m√©tier
  }
}
```

### **üéØ Test de Validation des Domaines**

**Posez-vous ces questions :**

1. **"Puis-je faire √©voluer ce domaine sans toucher aux autres ?"**
   - Oui ‚Üí Domaines bien s√©par√©s
   - Non ‚Üí Probablement m√™me domaine

2. **"Mes Application Services font-ils principalement de la coordination ?"**
   - Oui ‚Üí Domaines bien s√©par√©s
   - Non, ils contiennent de la logique m√©tier ‚Üí Fronti√®res √† revoir

3. **"Ai-je des experts m√©tier diff√©rents pour chaque domaine ?"**
   - Oui ‚Üí Domaines bien s√©par√©s
   - Non, m√™me expert ‚Üí Probablement m√™me domaine

4. **"Mes transactions sont-elles principalement intra-domaine ?"**
   - Oui ‚Üí Domaines bien s√©par√©s
   - Non, toujours cross-domaine ‚Üí Fronti√®res √† revoir
